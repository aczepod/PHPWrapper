<?php

/**
 * <i>COntologyNode</i> class definition.
 *
 * This file contains the class definition of <b>COntologyNode</b> which represents the
 * ancestor of ontology node classes.
 *
 *	@package	MyWrapper
 *	@subpackage	Ontology
 *
 *	@author		Milko A. Škofič <m.skofic@cgiar.org>
 *	@version	1.00 10/09/2012
 */

/*=======================================================================================
 *																						*
 *									COntologyNode.php									*
 *																						*
 *======================================================================================*/

/**
 * Local definitions.
 *
 * This include file contains common offset definitions.
 */
require_once( "COntologyNode.inc.php" );

/**
 * Kinds.
 *
 * This includes the kind definitions.
 */
require_once( kPATH_MYWRAPPER_LIBRARY_DEFINE."/Kinds.inc.php" );

/**
 * Terms.
 *
 * This includes the term class definitions.
 */
require_once( kPATH_MYWRAPPER_LIBRARY_CLASS."/COntologyTerm.php" );

/**
 * Ancestor.
 *
 * This includes the ancestor class definitions.
 */
require_once( kPATH_MYWRAPPER_LIBRARY_CLASS."/CNode.php" );

/**
 * <h4>Ontology node object</h4>
 *
 * An ontology node is essentially a term, {@link COntologyTerm}, placed in a specific
 * context of relations with other nodes, holding a series of attributes specific to the
 * node.
 *
 * This class extends its ancestor, {@link CNode}, by asserting the data types of the
 * object's attributes and by setting related object's references.
 *
 * <ul>
 *	<li><i>Term</i>: The term, or the inherited <tt>{@link kTAG_TERM}</tt> tag, in this
 *		class is a reference to an instance of the {@link COntologyTerm} class, constituted
 *		by its native identifier, {@link kTAG_NID}. At commit time,
 *		{@link _PrecommitRelated()}, we commit the eventual term instance and check if the
 *		value provided to the {@link Term()} member accessor is a term reference; we also
 *		manage its {@link kTAG_NODES} attribute by adding or removing the current node's
 *		{@link kTAG_NID} from the term's {@link kTAG_NODES} list depending on whether the
 *		term was referenced or the node deleted.
 *	<li><i>Type</i>: The type, <tt>{@link Type()}</tt> or the inherited
 *		<tt>{@link kTAG_TYPE}</tt> tag, in this class is required to belong to a specific
 *		set of values, the {@link Type()} method's documentation lists them.
 *	<li><i>Edge references</i>: The edge references, <tt>{@link kTAG_EDGES}</tt> tag,
 *		represents the {@link COntologyEdge} object references in which the current node was
 *		referenced as the subject or object of a relationship. It is either the count or
 *		an array of {@link COntologyEdge} {@link kTAG_NID} attributes, depending on the
 *		value of the {@link kSWITCH_kTAG_EDGES} flag:
 *	 <ul>
 *		<li><tt>0x2</tt>: <i>Keep count of edge references</i>. This means that the
 *			{@link kTAG_EDGES} attribute will be a reference count.
 *		<li><tt>0x3</tt>: <i>Keep list of edge references</i>. This means that the
 *			{@link kTAG_EDGES} attribute will be a list of references.
 *		<li><tt>0x0</tt> <i>or other</i>: <i>Don't handle this information</i>. This means
 *			that the {@link kTAG_EDGES} attribute will not be handled.
 *	 </ul>
 *		This attribute is read-only and is managed internally.
 * </ul>
 *
 * Since the class represents a term in context, there is no combination of attributes that
 * can be used to uniquely identify the object, for this reason the object does not
 * feature the {@link kTAG_GID} attribute, so it is the duty of the hosting container to
 * provide the {@link kTAG_NID} identifier. In this class we use two main strategies to
 * identify nodes:
*
 * <ul>
 *	<li><i>Sequence numbers</i>: The {@link kTAG_NID} attribute is constituted by an
 *		integer which is a sequence number generated by the
 *		{@link CContainer::NextSequence()} method of a default container named
 *		{@link kCONTAINER_SEQUENCE_NAME} with a {@link kSEQUENCE_KEY_NODE} key.
 *	<li><i>Graph nodes</i>: If the node container features the {@link kOFFSET_GRAPH} offset,
 *		this means that the server is also connected to a graph storage engine, in that
 *		case a new node will be created in the graph container, {@link CGraphContainer}, and
 *		the current object will use its identifier as the {@link kTAG_NID} attribute.
 * </ul>
 *
 * Once the node has been committed, it will not be possible to modify the term,
 * {@link kTAG_TERM}. 
 *
 * When inserting a new node, the class will also make sure that the referenced term
 * receives the newly created node identifier in its {@link kTAG_NODES} offset.
 *
 * This class prevents updating the full object once it has been inserted for the first
 * time. This behaviour is necessary because nodes are referenced by many other objects, so
 * updating a full node object is risky, since it may have been updated elsewhere: for this
 * reason the {@link Update()} and {@link Replace()} methods will raise an exception.
 *
 * The class implements the static method, {@link DefaultContainer()}, which, given a
 * database, will return the default nodes container; it will use the
 * {@link kCONTAINER_NODE_NAME} constant as the container name. Note that when passing
 * {@link CConnection} based objects to the persisting methods of this class, you should
 * provide preferably database instances, since this class may have to commit terms.
 *
 *	@package	MyWrapper
 *	@subpackage	Ontology
 */
class COntologyNode extends CNode
{
	/**
	 * Term object
	 *
	 * This data member holds the eventual term object when requested.
	 *
	 * @var COntologyTerm
	 */
	 protected $mTerm = NULL;

		

/*=======================================================================================
 *																						*
 *											MAGIC										*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	__toString																		*
	 *==================================================================================*/

	/**
	 * <h4>Return object name</h4>
	 *
	 * This method should return the current object's name which should represent the unique
	 * identifier of the object.
	 *
	 * By default we return the string representation of the term, {@link kTAG_TERM}.
	 *
	 * @access public
	 * @return string				The connection name.
	 */
	public function __toString()
	{
		//
		// Check native identifier.
		//
		if( $this->offsetExists( kTAG_NID ) )
			return (string) $this->offsetGet( kTAG_NID );						// ==>
		
		//
		// Yes, I know...
		//
		return NULL;																// ==>
	
	} // __toString.

		

/*=======================================================================================
 *																						*
 *								PUBLIC MEMBER INTERFACE									*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	Type																			*
	 *==================================================================================*/

	/**
	 * <h4>Manage node type set</h4>
	 *
	 * In this class we overload the parent method to assert the kind of elements that can
	 * be set in the offset. The offset accepts two types of elements:
	 *
	 * <ul>
	 *	<li><i>Data type</i>: The set accepts one of the following primary data types:
	 *	 <ul>
	 *		<li><i>{@link kTYPE_STRING}</i>: String, we assume in UTF8 character set.
	 *		<li><i>{@link kTYPE_INT32}</i>: 32 bit signed integer.
	 *		<li><i>{@link kTYPE_INT64}</i>: 64 bit signed integer.
	 *		<li><i>{@link kTYPE_FLOAT}</i>: Floating point number.
	 *		<li><i>{@link kTYPE_BOOLEAN}</i>: An <tt>on</tt>/<tt>off</tt> switch.
	 *		<li><i>{@link kTYPE_BINARY_STRING}</i>: A binary string.
	 *		<li><i>{@link kTYPE_DATE_STRING}</i>: A date.
	 *		<li><i>{@link kTYPE_TIME_STRING}</i>: A date and time.
	 *		<li><i>{@link kTYPE_STAMP}</i>: A native timestamp.
	 *		<li><i>{@link kTYPE_STRUCT}</i>: A structure container.
	 *		<li><i>{@link kTYPE_ENUM}</i>: Enumerated scalar, this data type resolves by
	 *			default to a string and indicates that the node refers to a controlled
	 *			vocabulary scalar whose elements will be found related to the current node.
	 *		<li><i>{@link kTYPE_ENUM_SET}</i>: Enumerated set, this data type resolves by
	 *			default to a list of string elements and indicates that the node refers to
	 *			an enumerated set whose elements will be found related to the current node.
	 *	 </ul>
	 *		Only one of the above may be present in the list, when adding a new element, if
	 *		the offset already contains a data type, this will be replaced by the new one.
	 *	<li><i>Cardinality</i>: The set accepts one or more cardinality indicators from the
	 *		following set:
	 *	 <ul>
	 *		<li><i>{@link kTYPE_REQUIRED}</i>: Required, the element referred by the
	 *			current node is required and cannot be omitted; if this tag is missing, it
	 *			means that the element is optional.
	 *		<li><i>{@link kTYPE_RESTRICTED}</i>: Restricted, the element referred by the
	 *			current node is restricted to an enumerated set; if this tag is missing, it
	 *			means that the element may take values not belonging to the enumerated set.
	 *		<li><i>{@link kTYPE_COMPUTED}</i>: Computed, the element referred by the
	 *			current node is computed or set automatically; if this tag is missing, it
	 *			means that the element must be set explicitly.
	 *		<li><i>{@link kTYPE_LOCKED}</i>: Locked, the element referred by the
	 *			current node will be locked or read-only once the object has been committed;
	 *			if this tag is missing, it means that the element may be modified after
	 *			committing the object.
	 *		<li><i>{@link kTYPE_ARRAY}</i>: Array, the element referred by the current
	 *			node is a list in which each element is of the data type indicated by the
	 *			previous set; if this tag is missing, it means that the element is a scalar.
	 *	 </ul>
	 * </ul>
	 *
	 * @param mixed					$theValue			Type or operation.
	 * @param mixed					$theOperation		Operation.
	 * @param boolean				$getOld				<tt>TRUE</tt> get old value.
	 *
	 * @access public
	 * @return mixed				<i>New</i> or <i>old</i> type.
	 */
	public function Type( $theValue = NULL, $theOperation = NULL, $getOld = FALSE )
	{
		//
		// Handle multiple parameters:
		//
		if( is_array( $theValue ) )
		{
			//
			// Init local storage.
			//
			$result = Array();
			$count = count( $theValue );
			$current = $this->offsetGet( kTAG_TYPE );
			
			//
			// Check operation.
			//
			if( is_array( $theOperation )
			 && (count( $theOperation ) != $count) )
				throw new Exception
						( "Values and operations counts do not match",
						  kERROR_PARAMETER );									// !@! ==>
			
			//
			// Iterate values.
			//
			foreach( $theValue as $index => $value )
			{
				//
				// Set operation.
				//
				$operation = ( is_array( $theOperation ) )
						   ? $theOperation[ $index ]
						   : $theOperation;
				
				//
				// Get result.
				//
				$result[] = parent::Type( $value, $operation, $getOld );
			
			} // Iterating list of values.
			
			return $result;															// ==>
		
		} // Multiple parameters.
		
		//
		// Check add operation.
		//
		if( ($theOperation !== NULL)
		 && ($theOperation !== FALSE) )
		{
			//
			// Check value.
			//
			switch( $theValue )
			{
				//
				// Handle data types.
				//
				case kTYPE_STRING:
				case kTYPE_INT:
				case kTYPE_INT32:
				case kTYPE_INT64:
				case kTYPE_FLOAT:
				case kTYPE_BOOLEAN:
				case kTYPE_ANY:

				case kTYPE_BINARY_STRING:
				case kTYPE_DATE_STRING:
				case kTYPE_TIME_STRING:
				case kTYPE_REGEX_STRING:
				
				case kTYPE_LSTRING:
				case kTYPE_STAMP:
				case kTYPE_STRUCT:
				
				case kTYPE_PHP:
				case kTYPE_JSON:
				case kTYPE_XML:
				case kTYPE_SVG:
				
				case kTYPE_MongoId:
				case kTYPE_MongoCode:
				
				case kTYPE_ENUM:
				case kTYPE_ENUM_SET:
					//
					// Remove eventual existing data type.
					//
					parent::Type( array( kTYPE_STRING, kTYPE_INT32,
										 kTYPE_INT64, kTYPE_FLOAT,
										 kTYPE_DATE_STRING, kTYPE_TIME_STRING,
										 kTYPE_STAMP, kTYPE_BOOLEAN,
										 kTYPE_BINARY_STRING, kTYPE_ENUM, kTYPE_ENUM_SET ),
								  FALSE );
			
				case kTYPE_REQUIRED:
				case kTYPE_RESTRICTED:
				case kTYPE_COMPUTED:
				case kTYPE_LOCKED:
				case kTYPE_ARRAY:
					break;
				
				default:
					throw new Exception
							( "Unsupported type",
							  kERROR_PARAMETER );								// !@! ==>
			
			} // Parsed value.
		
		} // Add operation.
		
		return parent::Type( $theValue, $theOperation, $getOld );					// ==>

	} // Type.

		

/*=======================================================================================
 *																						*
 *							PUBLIC RELATED MEMBER INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	LoadTerm																		*
	 *==================================================================================*/

	/**
	 * <h4>Load term object</h4>
	 *
	 * This method will return the current term object: if the term is not set, the method
	 * will return <tt>NULL</tt>; if the term cannot be found, the method will raise an
	 * exception.
	 *
	 * The object will also be loaded in a data member that can function as a cache.
	 *
	 * The method features two parameters: the first refers to the container in which the
	 * term is stored, the second is a boolean flag that determines whether the object
	 * is to be read, or if the cached copy can be used.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param boolean				$doReload			Reload if <tt>TRUE</tt>.
	 *
	 * @access public
	 * @return COntologyTerm		Term object or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 *
	 * @uses NewObject()
	 *
	 * @see kTAG_TERM
	 */
	public function LoadTerm( CConnection $theConnection, $doReload = FALSE )
	{
		//
		// Check offset.
		//
		if( $this->offsetExists( kTAG_TERM ) )
		{
			//
			// Refresh cache.
			// Uncommitted terms are cached by default.
			//
			if( $doReload					// Reload,
			 || ($this->mTerm === NULL) )	// or not cached.
			{
				//
				// Handle term object.
				//
				$term = $this->offsetGet( kTAG_TERM );
				if( $term instanceof COntologyTerm )
					return $term;													// ==>
				
				//
				// Load term object.
				//
				$this->mTerm
					= COntologyTerm::Resolve(
						COntologyTerm::ResolveClassContainer( $theConnection, TRUE ),
						$term,
						NULL,
						TRUE );
			
			} // Reload or empty cache.
			
			//
			// Handle not found.
			//
			if( $this->mTerm === NULL )
				throw new Exception
					( "Term not found",
					  kERROR_STATE );											// !@! ==>
		
		} // Has term.
		
		return $this->mTerm;														// ==>

	} // LoadTerm.

		

/*=======================================================================================
 *																						*
 *									PUBLIC GRAPH INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	GetGraphNode																	*
	 *==================================================================================*/

	/**
	 * <h4>Retrieve the graph node</h4>
	 *
	 * This method will retrieve the graph node associated with the current object, if the
	 * node is not found, the method will return <tt>NULL</tt>; if the provided connection
	 * does not handle graphs, the method will return <tt>FALSE</tt>.
	 *
	 * If you omit the node identifier, the method will assume you are requesting the
	 * current object graph node.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param integer				$theIdentifier		Graph node ID.
	 *
	 * @access public
	 * @return mixed				Related graph node.
	 */
	public function GetGraphNode( CConnection $theConnection, $theIdentifier = NULL )
	{
		//
		// Normalise properties.
		//
		if( $theConnection->offsetExists( kOFFSET_GRAPH ) )
		{
			//
			// Set identifier.
			//
			if( $theIdentifier === NULL )
				$theIdentifier = $this->offsetGet( kTAG_NID );
			
			//
			// Check identifier.
			//
			if( $theIdentifier !== NULL )
				return $theConnection->offsetGet( kOFFSET_GRAPH )
					->GetNode( $theIdentifier );									// ==>
			
			throw new Exception
				( "The current node was not yet committed",
				  kERROR_STATE );												// !@! ==>
		
		} // Has graph client.
		
		return FALSE;																// ==>
	
	} // _GetGraphNode.

	 
	/*===================================================================================
	 *	GetGraphNodeProperties															*
	 *==================================================================================*/

	/**
	 * <h4>Retrieve the graph node properties</h4>
	 *
	 * This method will retrieve the properties of the graph node associated with the
	 * current object, if the node is not found, the method will return <tt>NULL</tt>; if
	 * the provided connection does not handle graphs, the method will return
	 * <tt>FALSE</tt>.
	 *
	 * If you omit the node identifier, the method will assume you are requesting the
	 * current object graph node properties.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param integer				$theIdentifier		Graph node ID.
	 *
	 * @access public
	 * @return array				Related graph node properties.
	 */
	public function GetGraphNodeProperties( CConnection $theConnection,
														$theIdentifier = NULL )
	{
		//
		// Get graph node.
		//
		$node = $this->GetGraphNode( $theConnection, $theIdentifier );
		if( ($node !== NULL)
		 && ($node !== FALSE) )
			return $theConnection->offsetGet( kOFFSET_GRAPH )
						->GetNodeProperties( $node );								// ==>
		
		return $node;																// ==>
	
	} // GetGraphNodeProperties.

		

/*=======================================================================================
 *																						*
 *								PUBLIC PERSISTENCE INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	Update																			*
	 *==================================================================================*/

	/**
	 * <h4>Update the object in a container</h4>
	 *
	 * We overload this method to raise an exception: objects of this class can only be
	 * inserted, after this one can only modify their attributes using the modification
	 * interface provided by container objects.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 *
	 * @access public
	 *
	 * @throws Exception
	 */
	public function Update( CConnection $theConnection )
	{
		//
		// Check if necessary.
		//
		if( $this->_IsDirty()
		 || (! $this->_IsCommitted()) )
		{
			//
			// Object is locked.
			//
			throw new Exception
				( "This object can only be inserted and modified",
				  kERROR_LOCKED );												// !@! ==>
		
		} // Dirty or not yet committed.
	
	} // Update.

	 
	/*===================================================================================
	 *	Replace																			*
	 *==================================================================================*/

	/**
	 * <h4>Replace the object into a container</h4>
	 *
	 * We overload this method to raise an exception: objects of this class can only be
	 * inserted, after this one can only modify their attributes using the modification
	 * interface provided by container objects.
	 *
	 * In this class we prevent replacing a committed object and allow inserting a non
	 * committed object.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 *
	 * @access public
	 * @return mixed				The object's native identifier.
	 */
	public function Replace( CConnection $theConnection )
	{
		//
		// Check if necessary.
		//
		if( $this->_IsDirty()
		 || (! $this->_IsCommitted()) )
		{
			//
			// Check if the object is not committed.
			//
			if( ! $this->_IsCommitted() )
				return parent::Replace( $theConnection );							// ==>
			
			//
			// Object is locked.
			//
			throw new Exception
				( "This object can only be inserted and modified",
				  kERROR_LOCKED );												// !@! ==>
		
		} // Dirty or not yet committed.
		
		return NULL;																// ==>
	
	} // Replace.

		

/*=======================================================================================
 *																						*
 *								STATIC CONTAINER INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	DefaultContainerName															*
	 *==================================================================================*/

	/**
	 * <h4>Return the default nodes container name</h4>
	 *
	 * This class uses the {@link kCONTAINER_NODE_NAME} default name.
	 *
	 * @static
	 * @return string				The default container name.
	 *
	 * @throws Exception
	 *
	 * @see kCONTAINER_NODE_NAME
	 */
	static function DefaultContainerName()				{	return kCONTAINER_NODE_NAME;	}

		

/*=======================================================================================
 *																						*
 *								STATIC RESOLUTION INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	Resolve																			*
	 *==================================================================================*/

	/**
	 * <h4>Resolve a node</h4>
	 *
	 * This method can be used to retrieve an existing node by identifier, or retrieve all
	 * nodes matching a term.
	 *
	 * The method accepts the following parameters:
	 *
	 * <ul>
	 *	<li><tt>$theConnection</tt>: This parameter represents the connection from which the
	 *		nodes container must be resolved. If this parameter cannot be correctly
	 *		determined, the method will raise an exception.
	 *	<li><tt>$theIdentifier</tt>: This parameter represents either the node identifier
	 *		or the term reference, depending on its type:
	 *	 <ul>
	 *		<li><tt>integer</tt>: In this case the method assumes that the parameter
	 *			represents the node identifier: it will attempt to retrieve the node, if it
	 *			is not found, the method will return <tt>NULL</tt>.
	 *		<li><tt>{@link COntologyTerm}</tt>: In this case the method will locate all
	 *			nodes that refer to the provided term. If the term is {@link _IsCommitted()}
	 *			the method will use its native identifier; if not, it will use its global
	 *			identifier if available, or assume the term does not exist.
	 *		<li><i>other</i>: Any other type will be interpreted either the term's native
	 *			identifier, or as the term's global identifier: the method will return all
	 *			nodes that refer to that term.
	 *	 </ul>
	 *	<li><tt>$doThrow</tt>: If <tt>TRUE</tt>, any failure to resolve the node will raise
	 *		an exception.
	 * </ul>
	 *
	 * The method will return an object if provided a node identifier, or an array of
	 * objects if provided a term reference; if there is no match the method will return
	 * <tt>NULL</tt>, or raise an exception if the last parameter is <tt>TRUE</tt>.
	 *
	 * <b>Note: do not provide an array containing the object in the identifier parameter,
	 * or you will get unexpected results.</b>
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param mixed					$theIdentifier		Node identifier or term reference.
	 * @param boolean				$doThrow			If <tt>TRUE</tt> raise an exception.
	 *
	 * @static
	 * @return COntologyNode		Matched node, found nodes or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 */
	static function Resolve( CConnection $theConnection, $theIdentifier, $doThrow = FALSE )
	{
		//
		// Check identifier.
		//
		if( $theIdentifier !== NULL )
		{
			//
			// Handle node identifier.
			//
			if( is_integer( $theIdentifier ) )
			{
				//
				// Get node.
				//
				$node = static::NewObject( $theConnection, $theIdentifier );
				if( (! $doThrow)
				 || ($node !== NULL) )
					return $node;													// ==>
				
				throw new Exception
					( "Node not found",
					  kERROR_NOT_FOUND );										// !@! ==>
			
			} // Provided node identifier.
			
			//
			// Handle term.
			//
			if( (! ($theIdentifier instanceof COntologyTerm))
			 || (! $theIdentifier->_IsCommitted()) )
			{
				//
				// Resolve term.
				//
				$theIdentifier = COntologyTerm::Resolve( $theConnection, $theIdentifier );
				if( $theIdentifier === NULL )
				{
					if( ! $doThrow )
						return NULL;												// ==>
					
					throw new Exception
						( "Node not found: unresolved term",
						  kERROR_NOT_FOUND );									// !@! ==>
				
				} // Unresolved term.
			
			} // Provided term reference or uncommitted term.
			
			//
			// Use term native identifier.
			//
			$theIdentifier = $theIdentifier->offsetGet( kTAG_NID );
			
			//
			// Resolve container.
			//
			$container = static::ResolveClassContainer( $theConnection, TRUE );
			
			//
			// Make query.
			//
			$query = $container->NewQuery();
			$query->AppendStatement(
				CQueryStatement::Equals(
					kTAG_TERM, $theIdentifier, kTYPE_BINARY_STRING ) );
			$rs = $container->Query( $query );
			if( $rs->count() )
			{
				//
				// Return list of nodes.
				//
				$list = Array();
				foreach( $rs as $document )
					$list[] = CPersistentObject::DocumentObject( $document );
				
				return $list;														// ==>
			
			} // Found at least one node.

			//
			// Raise exception.
			//
			if( $doThrow )
				throw new Exception
					( "Node not found",
					  kERROR_NOT_FOUND );										// !@! ==>
			
			return NULL;															// ==>
			
		} // Provided local or global identifier.
		
		throw new Exception
			( "Missing node identifier or term",
			  kERROR_PARAMETER );												// !@! ==>

	} // Resolve.

		

/*=======================================================================================
 *																						*
 *								PROTECTED OFFSET INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_Preset																			*
	 *==================================================================================*/

	/**
	 * <h4>Handle offset before setting it</h4>
	 *
	 * In this class we handle the term offset, if provided as an object we leave it
	 * unchanged only if not yet committed, if not, we convert it to its native identifier.
	 * We also ensure the provided term object to be an instance of {@link COntologyTerm} by
	 * asserting {@link CDocument} descendants to be of that class.
	 *
	 * This method will lock the {@link kTAG_FEATURES} and
	 * {@link kTAG_SCALES} offsets from any modification.
	 *
	 * @param reference			   &$theOffset			Offset.
	 * @param reference			   &$theValue			Value to set at offset.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @uses _IsCommitted()
	 * @uses _AssertClass()
	 *
	 * @see kTAG_TERM kTAG_FEATURES kTAG_SCALES
	 */
	protected function _Preset( &$theOffset, &$theValue )
	{
		//
		// Intercept reference offsets.
		//
		if( ($theOffset == kTAG_FEATURES)
		 || ($theOffset == kTAG_SCALES) )
			throw new Exception
				( "The [$theOffset] offset cannot be modified",
				  kERROR_LOCKED );												// !@! ==>
		
		//
		// Handle term.
		//
		if( $theOffset == kTAG_TERM )
		{
			//
			// Lock term if object is committed.
			//
			if( $this->_IsCommitted() )
				throw new Exception
					( "You cannot modify the [$theOffset] offset: "
					 ."the object is committed",
					  kERROR_LOCKED );											// !@! ==>
			
			//
			// Check value type.
			//
			$ok = $this->_AssertClass( $theValue, 'CDocument', 'COntologyTerm' );
			
			//
			// Handle wrong object.
			//
			if( $ok === FALSE )
				throw new Exception
					( "Cannot set term: "
					 ."the object must be a term reference or object",
					  kERROR_PARAMETER );										// !@! ==>
			
			//
			// Handle right object.
			//
			if( $ok )
			{
				//
				// Use native identifier.
				//
				if( $theValue->_IsCommitted() )
				{
					//
					// Check native identifier.
					//
					if( $theValue->offsetExists( kTAG_NID ) )
						$theValue = $theValue->offsetGet( kTAG_NID );
					else
						throw new Exception
							( "Cannot set term: "
							 ."the object is missing its native identifier",
							  kERROR_PARAMETER );								// !@! ==>
				
				} // Term is committed.
				
				//
				// Copy to data member.
				//
				else
					$this->mTerm = $theValue;
			
			} // Correct object class.
		
		} // Provided term.
		
		//
		// Call parent method.
		//
		parent::_Preset( $theOffset, $theValue );
	
	} // _Preset.

	 
	/*===================================================================================
	 *	_Preunset																		*
	 *==================================================================================*/

	/**
	 * <h4>Handle offset before unsetting it</h4>
	 *
	 * In this class we prevent the modification of the {@link kTAG_TERM} offset if the
	 * object is committed and of the {@link kTAG_FEATURES} and
	 * {@link kTAG_SCALES} offsets in all cases.
	 *
	 * @param reference			   &$theOffset			Offset.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @uses _IsCommitted()
	 *
	 * @see kTAG_FEATURES kTAG_SCALES kTAG_TERM
	 */
	protected function _Preunset( &$theOffset )
	{
		//
		// Intercept reference offsets.
		//
		if( ($theOffset == kTAG_FEATURES)
		 || ($theOffset == kTAG_SCALES) )
			throw new Exception
				( "The [$theOffset] offset cannot be modified",
				  kERROR_LOCKED );												// !@! ==>
		
		//
		// Lock term if object is committed.
		//
		if( ($theOffset == kTAG_TERM)
		 && $this->_IsCommitted() )
			throw new Exception
				( "You cannot modify the [$theOffset] offset: "
				 ."the object is committed",
				  kERROR_LOCKED );												// !@! ==>
		
		//
		// Call parent method.
		//
		parent::_Preunset( $theOffset );
	
	} // _Preunset.
		


/*=======================================================================================
 *																						*
 *							PROTECTED PRE-COMMIT INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_PrecommitRelated																*
	 *==================================================================================*/

	/**
	 * <h4>Handle embedded or related objects before committing</h4>
	 *
	 * In this class we commit the eventual term provided as an uncommitted object and
	 * replace the offset with the term's native identifier, or load the term if provided
	 * as an identifier.
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 * @return mixed
	 *
	 * @uses LoadTerm()
	 *
	 * @see kTAG_TERM
	 */
	protected function _PrecommitRelated( &$theConnection, &$theModifiers )
	{
		//
		// Call parent method.
		//
		$status = parent::_PrecommitRelated( $theConnection, $theModifiers );
		if( $status !== NULL )
			return $status;															// ==>
		
		//
		// Not deleting.
		//
		if( ! ($theModifiers & kFLAG_PERSIST_DELETE) )
		{
			//
			// Handle term object.
			// Note that we let _Preset() method take care of the specific class.
			// Note that we do not check for the term: it is required to be inited.
			//
			$term = $this->offsetGet( kTAG_TERM );
			if( $term instanceof COntologyTerm )
			{
				//
				// Commit.
				// Note that we insert, to ensure the object is new.
				//
				$term->Insert(
					COntologyTerm::ResolveClassContainer( $theConnection, TRUE ) );
				
				//
				// Cache it.
				//
				$this->mTerm = $term;
				
				//
				// Set identifier in term offset.
				//
				$this->offsetSet( kTAG_TERM, $term->offsetGet( kTAG_NID ) );
				
			} // Term is object.
			
			//
			// Handle term identifier.
			//
			else
				$this->LoadTerm( $theConnection, TRUE );
		
			//
			// Load term attributes.
			//
			$this->_LoadTermAttributes( $this->_TermAttributes() );
		
		} // Not deleting.
		
		return NULL;																// ==>
	
	} // _PrecommitRelated.

	 
	/*===================================================================================
	 *	_PrecommitIdentify																*
	 *==================================================================================*/

	/**
	 * <h4>Determine the identifiers before committing</h4>
	 *
	 * This method will take care of generating the sequence number that represents the
	 * object's native identifier, {@link kTAG_NID}.
	 *
	 * This value can be generated in two ways:
	 *
	 * <ul>
	 *	<li><i>The container has the graph reference, {@link kOFFSET_GRAPH}</i>: If the
	 *		provided container contains a reference to a graph container, it means that the
	 *		node must also be stored in the graph, this will be taken care by the
	 *		{@link _AddGraphNode()} method that will return the graph node's ID, which in
	 *		turn will become the current object's {@link kTAG_NID}.
	 *	<li><i>The container lacks the graph reference, {@link kOFFSET_GRAPH}</i>: If the
	 *		provided container does not hold a reference to a graph container, the object
	 *		identifier will be generated with a sequence number tagged
	 *		{@link kSEQUENCE_KEY_NODE}, this method will set the native identifier,
	 *		{@link kTAG_NID}, with this value.
	 * </ul>
	 *
	 * When deleting the object, if the provided container contains a reference to a graph
	 * container, this method will also delete the relative node from the graph.
	 *
	 * The parent method will then be called, which will ignore the global identifier,
	 * {@link kTAG_GID}, since the {@link _index()} method returns <tt>NULL</tt> and
	 * also ignore the native identifier, {@link kTAG_NID}, since it will have been set
	 * here.
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 * @return mixed
	 *
	 * @see kTAG_NID kSEQUENCE_KEY_NODE
	 * @see kFLAG_PERSIST_INSERT kFLAG_PERSIST_REPLACE
	 */
	protected function _PrecommitIdentify( &$theConnection, &$theModifiers )
	{
		//
		// Handle insert or replace.
		//
		if( (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_INSERT)
		 || (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_REPLACE) )
		{
			//
			// Set native identifier.
			// Note that we only operate on new objects,
			// this is because one cannot update objects derived from this class.
			//
			if( ! $this->offsetExists( kTAG_NID ) )
			{
				//
				// Resolve container.
				//
				$container = static::ResolveClassContainer( $theConnection, TRUE );
				
				//
				// Handle graph.
				//
				if( $container->offsetExists( kOFFSET_GRAPH ) )
					$id = $this->_AddGraphNode( $container->offsetGet( kOFFSET_GRAPH ) );
				
				//
				// Handle sequence number.
				//
				else
					$id = $container->NextSequence( kSEQUENCE_KEY_NODE, TRUE );
				
				//
				// Set identifier.
				//
				$this->offsetSet( kTAG_NID, $id );
			
			} // Missing native identifier.
		
		} // Insert or replace.
		
		//
		// Handle delete.
		//
		elseif( $theModifiers & kFLAG_PERSIST_DELETE )
		{
			//
			// Resolve container.
			//
			$container = static::ResolveClassContainer( $theConnection, TRUE );
			
			//
			// Handle graph.
			//
			if( $container->offsetExists( kOFFSET_GRAPH ) )
				$container->offsetGet( kOFFSET_GRAPH )
					->DelNode( $this->offsetGet( kTAG_NID ) );
		
		} // Delete.
	
		//
		// Call parent method.
		//
		return parent::_PrecommitIdentify( $theConnection, $theModifiers );			// ==>
		
	} // _PrecommitIdentify.
		


/*=======================================================================================
 *																						*
 *							PROTECTED POST-COMMIT INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_PostcommitRelated																*
	 *==================================================================================*/

	/**
	 * <h4>Update related objects after committing</h4>
	 *
	 * In this class we handle referenced terms, {@link kTAG_TERM}: depending on the value
	 * of the {@link kSWITCH_kTAG_NODES} flag we do the following:
	 *
	 * <ul>
	 *	<li><tt>0x2</tt>: <i>Keep count of references</i>. This means that the
	 *		{@link kTAG_NODES} attribute of the term referenced by the {@link kTAG_TERM}
	 *		attribute will be incremented when the object is inserted, or decremented when
	 *		deleted.
	 *	<li><tt>0x3</tt>: <i>Keep list of references</i>. This means that a reference to the
	 *		current object will be added to the {@link kTAG_NODES} attribute of the term
	 *		referenced by {@link kTAG_TERM} attribute of the current object when the latter
	 *		is inserted, and removed when the object is deleted.
	 *	<li><tt>0x0</tt> <i>or other</i>: <i>Don't handle this information</i>. This means
	 *		that the {@link kTAG_NODES} attribute will not be handled.
	 * </ul>
	 *
	 * Note that you should provide either a database connection or the <i>term</i>
	 * container to this method in order to make it work!
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 *
	 * @uses _IsCommitted()
	 * @uses _ReferenceInObject()
	 *
	 * @see kFLAG_PERSIST_INSERT kFLAG_PERSIST_REPLACE
	 */
	protected function _PostcommitRelated( &$theConnection, &$theModifiers )
	{
		//
		// Call parent method.
		//
		parent::_PostcommitRelated( $theConnection, $theModifiers );
		
		//
		// Check term reference.
		//
		if( $this->offsetExists( kTAG_TERM ) )
		{
			//
			// Handle insert or replace.
			//
			if( (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_INSERT)
			 || (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_REPLACE) )
			{
				//
				// Check if not yet committed.
				//
				if( ! $this->_IsCommitted() )
					$this->_ReferenceInObject(
						COntologyTerm::ResolveContainer( $theConnection, TRUE ),
						kSWITCH_kTAG_NODES,
						$this->offsetGet( kTAG_TERM ),
						kTAG_NODES,
						1 );
			
			} // Insert or replace.
			
			//
			// Check if deleting.
			//
			elseif( $theModifiers & kFLAG_PERSIST_DELETE )
				$this->_ReferenceInObject(
					COntologyTerm::ResolveContainer( $theConnection, TRUE ),
					kSWITCH_kTAG_NODES,
					$this->offsetGet( kTAG_TERM ),
					kTAG_NODES,
					-1 );
		
		} // Has term reference.
		
	} // _PostcommitRelated.

	 
	/*===================================================================================
	 *	_PostcommitCleanup																*
	 *==================================================================================*/

	/**
	 * <h4>Cleanup the object after committing</h4>
	 *
	 * In this class we reset the term object cache, we set the data member to <tt>NULL</tt>
	 * so that next time one wants to retrieve the term object, it will have to be refreshed
	 * and its references actualised.
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 */
	protected function _PostcommitCleanup( &$theConnection, &$theModifiers )
	{
		//
		// Call parent method.
		//
		parent::_PostcommitCleanup( $theConnection, $theModifiers );
		
		//
		// Reset term cache.
		//
		$this->mTerm = NULL;
	
	} // _PostcommitCleanup.

		

/*=======================================================================================
 *																						*
 *								PROTECTED REFERENCE INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_LoadTermAttributes																*
	 *==================================================================================*/

	/**
	 * <h4>Load term attributes</h4>
	 *
	 * This method can be used to copy selected term attributes to the current object, this
	 * is used to cache searchable term attributes directly in the node, to prevent having
	 * to search both terms and nodes.
	 *
	 * The method accepts a single parameter, <tt>$theAttributes</tt>, which is the list of
	 * term attribute tags which should be copied to this object. If the parameter is
	 * omitted, the method will copy all attributes.
	 *
	 * This method will first load the term attributes, then overwrite them with the node
	 * attributes, this effectively makes matching node attributes overwrite term
	 * attributes.
	 *
	 * The method is called by {@link _Precommit()}, in derived classes you can call the
	 * parent method and add custom attributes in the derived method.
	 *
	 * In this class this method is not called, in derived classes you should explicitly
	 * invoke it.
	 *
	 * @param array					$theAttributes		Term attribute tags list.
	 *
	 * @access protected
	 *
	 * @see kTAG_TERM kTAG_NODES
	 * @see kFLAG_PERSIST_MODIFY kFLAG_MODIFY_ADDSET kFLAG_MODIFY_PULL
	 */
	protected function _LoadTermAttributes( $theAttributes = NULL )
	{
		//
		// Check term.
		//
		if( $this->offsetExists( kTAG_TERM ) )
		{
			//
			// Check attributes.
			//
			if( $theAttributes !== NULL )
			{
				//
				// Normalise attributes.
				//
				if( ! is_array( $theAttributes ) )
					$theAttributes = array( $theAttributes );
				
				//
				// Init local storage.
				//
				$properties = Array();
				
				//
				// Iterate term attributes.
				//
				foreach( $theAttributes as $tag )
				{
					if( $this->mTerm->offsetExists( $tag ) )
						$properties[ $tag ]
							= $this->mTerm->offsetGet( $tag );
				}
				
				//
				// Iterate node attributes.
				//
				foreach( $this as $tag => $value )
					$properties[ $tag ] = $value;
				
				//
				// Replace attributes.
				//
				$this->exchangeArray( $properties );
			
			} // Provided attribute tags.
		
		} // Object has term.
	
	} // _LoadTermAttributes.

	 
	/*===================================================================================
	 *	_TermAttributes																	*
	 *==================================================================================*/

	/**
	 * <h4>List term attributes</h4>
	 *
	 * This method can be used to return the list of term attributes that will be copied
	 * into the node, it should return a list of tag identifiers that will be used to select
	 * attributes from the node's term.
	 *
	 * In this class we copy no term attributes to the node, so we return <tt>NULL</tt>, in
	 * derived classes you can return an array.
	 *
	 * @access protected
	 * @return array
	 */
	protected function _TermAttributes()								{	return NULL;	}

		

/*=======================================================================================
 *																						*
 *								PROTECTED GRAPH INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_AddGraphNode																	*
	 *==================================================================================*/

	/**
	 * <h4>Create or update a graph node</h4>
	 *
	 * This method will create and save a new graph node in the provided graph container and
	 * return its newly created identifier, or retrieve a graph node and update its
	 * properties.
	 *
	 * This method is called by {@link _PrecommitIdentify()} to set the new node
	 * {@link kTAG_NID} and from other methods to update the node properties.
	 *
	 * This method will use the {@link _GraphNodeProperties()} method to determine which
	 * attributes will be set in the graph node.
	 *
	 * The method expects the following parameters:
	 *
	 * <ul>
	 *	<li><tt>$theGraph</tt>: The graph container or client.
	 *	<li><tt>$theIdentifier</tt>: The graph node identifier, if provided, it means that
	 *		we want to update an existing graph node and the parameter is its identifier. If
	 *		the node cannot be located in the graph, the method should raise an exception.
	 *		If the parameter is not provided, it means that we want to create a new graph
	 *		node.
	 *	<li><tt>$theProperties</tt>: The graph node properties, if provided, the new or
	 *		existing node will have its properties replaced with the ones in this parameter;
	 *		if not provided, the {@link _GraphNodeProperties()} method will be used to
	 *		extract the required properties from the current node and update or set the
	 *		graph node's.
	 * </ul>
	 *
	 * The method should raise an exception if the operation fails.
	 *
	 * @param CGraphContainer		$theGraph			Graph container.
	 * @param integer				$theIdentifier		Graph node identifier.
	 * @param array					$theProperties		Graph node properties.
	 *
	 * @access protected
	 * @return integer				Newly created or existing node ID.
	 */
	protected function _AddGraphNode( CGraphContainer $theGraph, $theIdentifier = NULL,
																 $theProperties = NULL )
	{
		//
		// Normalise properties.
		//
		if( $theProperties instanceof ArrayObject )
			$theProperties = $theProperties->getArrayCopy();
		elseif( ! is_array( $theProperties ) )
			$theProperties = $this->_GraphNodeProperties();
		
		//
		// Create node.
		//
		if( $theIdentifier === NULL )
		{
			//
			// Create new node.
			//
			$node = $theGraph->NewNode( $theProperties );
			
			//
			// Save node.
			//
			$id = $theGraph->SetNode( $node );
		
		} // New node.
		
		//
		// Retrieve node.
		//
		else
		{
			//
			// Retrieve node.
			//
			$node = $theGraph->GetNode( $theIdentifier );
			if( $node === NULL )
				throw new Exception
					( "Graph node not found",
					  kERROR_NOT_FOUND );										// !@! ==>
			
			//
			// Save node.
			//
			$id = $theGraph->SetNode( $node, $theProperties );
		
		} // Existing node.
		
		//
		// Return identifier.
		//
		if( is_integer( $id ) )
			return $id;																// ==>
		
		throw new Exception
			( "Unable to create graph node",
			  kERROR_STATE );													// !@! ==>
	
	} // _AddGraphNode.

	 
	/*===================================================================================
	 *	_GraphNodeProperties															*
	 *==================================================================================*/

	/**
	 * <h4>Return the list of graph node tags</h4>
	 *
	 * This method should return an array of attributes which represents the list of
	 * properties which should be transferred to the graph node.
	 *
	 * This method can be overloaded as more specialised node classes are developed, the
	 * main reason for this method is to control which properties should be copied to the
	 * graph and which properties are supported by the graph nodes.
	 *
	 * The method accepts an optional parameter, <tt>$theProperties</tt>, which represents
	 * an array of attributes that can be filtered by this method: only those elements which
	 * match the tags supported by this method will be selected. This parameter can be an
	 * array or ArrayObject, any other type will trigger an exception.
	 *
	 * In this class we copy the {@link kTAG_GID}, {@link kTAG_CATEGORY}, {@link kTAG_KIND}
	 * and {@link kTAG_TYPE} attributes. Note that the {@link kTAG_GID} attribute will only
	 * be copied in derived classes that add that term's attribute to the current node.
	 *
	 * @param array					$theProperties		Base properties.
	 *
	 * @access protected
	 * @return array				List of properties.
	 */
	protected function _GraphNodeProperties( $theProperties = NULL )
	{
		//
		// Init local storage.
		//
		$properties = Array();
		$tags = array( kTAG_GID, kTAG_CATEGORY, kTAG_KIND, kTAG_TYPE );
		
		//
		// Set properties.
		//
		if( $theProperties !== NULL )
		{
			if( $theProperties instanceof ArrayObject )
				$theProperties = $theProperties->getArrayCopy();
			if( ! is_array( $theProperties ) )
				throw new Exception
					( "Invalid properties list format",
					  kERROR_PARAMETER );										// !@! ==>
		}
		else
			$theProperties = $this->getArrayCopy();
		
		//
		// Collect properties.
		//
		foreach( $tags as $tag )
		{
			if( array_key_exists( $tag, $theProperties ) )
				$properties[ $tag ] = $theProperties[ $tag ];
		}
		
		return $properties;															// ==>
	
	} // _GraphNodeProperties.
		


/*=======================================================================================
 *																						*
 *								PROTECTED EDGE INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_NewEdge																		*
	 *==================================================================================*/

	/**
	 * <h4>Return a new edge instance</h4>
	 *
	 * In this class we return a {@link COntologyEdge} instance.
	 *
	 * @access protected
	 * @return CEdge
	 */
	protected function _NewEdge()							{	return new COntologyEdge();	}

	 

} // class COntologyNode.


?>
