<?php

/**
 * <i>COntologyEdge</i> class definition.
 *
 * This file contains the class definition of <b>COntologyEdge</b> which represents the
 * ancestor of ontology edge classes.
 *
 *	@package	MyWrapper
 *	@subpackage	Ontology
 *
 *	@author		Milko A. Škofič <m.skofic@cgiar.org>
 *	@version	1.00 14/09/2012
 */

/*=======================================================================================
 *																						*
 *									COntologyEdge.php									*
 *																						*
 *======================================================================================*/

/**
 * Local definitions.
 *
 * This include file contains common offset definitions.
 */
require_once( "COntologyEdge.inc.php" );

/**
 * Nodes.
 *
 * This includes the node class definitions.
 */
require_once( kPATH_MYWRAPPER_LIBRARY_CLASS."/COntologyNode.php" );

/**
 * Ancestor.
 *
 * This includes the ancestor class definitions.
 */
require_once( kPATH_MYWRAPPER_LIBRARY_CLASS."/CEdge.php" );

/**
 * <h4>Ontology edge object ancestor</h4>
 *
 * This class extends its ancestor, {@link CEdge}, by asserting the {@link Subject()} and
 * {@link Object()} to be {@link COntologyNode} instance references, and the
 * {@link Predicate} to be an {@link COntologyTerm} instance.
 *
 * <ul>
 *	<li><i>Subject vertex</i>: The subject vertex, <tt>{@link Subject()}</tt>, in this class
 *		is represented by a reference to a {@link COntologyNode} instance, constituted by
 *		the latter's {@link kTAG_NID}.
 *	<li><i>Relationship predicate</i>: The predicate, <tt>{@link Predicate()}</tt>, in this
 *		class is represented by a reference to a {@link COntologyTerm} instance, constituted
 *		by the latter's {@link kTAG_NID}.
 *	<li><i>Object vertex</i>: The object vertex, <tt>{@link Object()}</tt>, in this class
 *		is represented by a reference to a {@link COntologyNode} instance, constituted by
 *		the latter's {@link kTAG_NID}.
 *	<li><i>Global identifier</i>: The global identifier, <tt>{@link GID()}</tt> or the
 *		<tt>{@link kTAG_GID}</tt> tag, in this class is generated by concatenating the
 *		subject node's {@link kTAG_NID}, the predicate term's {@link kTAG_GID} and the
 *		object node's {@link kTAG_NID}, all separated by the
 *		{@link kTOKEN_INDEX_SEPARATOR} token.
 * </ul>
 *
 * This class overloads the inherited identification workflow, the {@link kTAG_NID}
 * attribute is constituted by an integer which is a sequence number generated by the
 * {@link CContainer::NextSequence()} method of a default container named
 * {@link kCONTAINER_SEQUENCE_NAME} with a key {@link kSEQUENCE_KEY_EDGE}.
 *
 * The class also features a unique identifier, {@link kTAG_UID}, which receives the hash of
 * the global identifier, {@link kTAG_GID}, this value will be used to prevent duplicates.
 *
 * When adding vertices and predicates to the object, these can be provided as objects and
 * if these objects are not committed, they will be stored before the current edge object is
 * committed.
 *
 * The class implements the static method, {@link DefaultContainer()}, which, given a
 * database, will return the default edges container; it will use the
 * {@link kCONTAINER_EDGE_NAME} constant as the container name. Note that when passing
 * {@link CConnection} based objects to the persisting methods of this class, you should
 * provide preferably database instances, since this class may have to commit nodes and
 * terms.
 *
 *	@package	MyWrapper
 *	@subpackage	Ontology
 */
class COntologyEdge extends CEdge
{
	/**
	 * <b>Subject node object</b>
	 *
	 * This data member holds the subject node object when requested.
	 *
	 * @var COntologyNode
	 */
	 protected $mSubject = NULL;

	/**
	 * <b>Predicate term object</b>
	 *
	 * This data member holds the predicate term object when requested.
	 *
	 * @var COntologyTerm
	 */
	 protected $mPredicate = NULL;

	/**
	 * <b>Object node object</b>
	 *
	 * This data member holds the object node object when requested.
	 *
	 * @var COntologyNode
	 */
	 protected $mObject = NULL;

		

/*=======================================================================================
 *																						*
 *								PUBLIC PERSISTENCE INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	Insert																			*
	 *==================================================================================*/

	/**
	 * <h4>Insert the object into a container</h4>
	 *
	 * We overload this method to prevent creating two edges with the same elements.
	 * We first check if there is another edge with the same subject/predicate/object
	 * sequence, in that case we replace the current object attributes with the found edge;
	 * if no other edge shares the same terms, the method will perform as usual.
	 *
	 * If any of the relationship terms cannot be resolved, the method will proceed as in
	 * the parent class.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 *
	 * @access public
	 * @return mixed				The object's native identifier.
	 *
	 * @see kFLAG_PERSIST_INSERT
	 */
	public function Insert( CConnection $theConnection )
	{
		//
		// Check if necessary.
		//
		if( $this->_IsDirty()
		 || (! $this->_IsCommitted()) )
		{
			//
			// Resolve edge.
			//
			$edge = $this->Resolve( $theConnection, $this );
			if( $edge !== NULL )
			{
				//
				// Replace object attributes.
				//
				$this->exchangeArray( $edge->getArrayCopy() );
				
				//
				// Update current object status.
				//
				$op = kFLAG_PERSIST_INSERT;
				$this->_PostcommitStatus( $theConnection, $op );
				
				return $this->NID();												// ==>
			
			} // Duplicate edge.
			
			return parent::Insert( $theConnection );								// ==>
		
		} // Dirty or not yet committed.
		
		return NULL;																// ==>
	
	} // Insert.

		

/*=======================================================================================
 *																						*
 *							PUBLIC RELATED MEMBER INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	LoadSubject																		*
	 *==================================================================================*/

	/**
	 * <h4>Load subject node object</h4>
	 *
	 * This method will return the current subject node object: if the node is not set, the
	 * method will return <tt>NULL</tt>; if the node cannot be found, the method will raise
	 * an exception.
	 *
	 * The object will also be loaded in a data member that can function as a cache.
	 *
	 * The method features two parameters: the first refers to the container in which the
	 * node is stored, the second is a boolean flag that determines whether the object
	 * is to be read, or if the cached copy can be used.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param boolean				$doReload			Reload if <tt>TRUE</tt>.
	 *
	 * @access public
	 * @return COntologyNode		Node object or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 * return COntologyNode
	 *
	 * @uses NewObject()
	 *
	 * @see kTAG_SUBJECT
	 */
	public function LoadSubject( CConnection $theConnection, $doReload = FALSE )
	{
		//
		// Check offset.
		//
		if( $this->offsetExists( kTAG_SUBJECT ) )
		{
			//
			// Refresh cache.
			// Uncommitted nodes are cached by default.
			//
			if( $doReload						// Reload,
			 || ($this->mSubject === NULL) )	// or not cached.
			{
				//
				// Handle node object.
				//
				$node = $this->offsetGet( kTAG_SUBJECT );
				if( $node instanceof COntologyNode )
					return $node;													// ==>
				
				//
				// Load node object.
				//
				$this->mSubject
					= $this->NewObject
						( COntologyNode::ResolveClassContainer( $theConnection, TRUE ),
						  $node );
			
			} // Reload or empty cache.
			
			//
			// Handle not found.
			//
			if( $this->mSubject === NULL )
				throw new Exception
					( "Subject vertex node [$node] not found",
					  kERROR_STATE );											// !@! ==>
		
		} // Has term.
		
		return $this->mSubject;														// ==>

	} // LoadSubject.

	 
	/*===================================================================================
	 *	LoadPredicate																	*
	 *==================================================================================*/

	/**
	 * <h4>Load predicate term object</h4>
	 *
	 * This method will return the current predicate term object: if the term is not set,
	 * the method will return <tt>NULL</tt>; if the term cannot be found, the method will
	 * raise an exception.
	 *
	 * The object will also be loaded in a data member that can function as a cache.
	 *
	 * The method features two parameters: the first refers to the container in which the
	 * term is stored, the second is a boolean flag that determines whether the object
	 * is to be read, or if the cached copy can be used.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param boolean				$doReload			Reload if <tt>TRUE</tt>.
	 *
	 * @access public
	 * @return COntologyTerm		Term object or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 *
	 * @uses NewObject()
	 *
	 * @see kTAG_PREDICATE
	 */
	public function LoadPredicate( CConnection $theConnection, $doReload = FALSE )
	{
		//
		// Check offset.
		//
		if( $this->offsetExists( kTAG_PREDICATE ) )
		{
			//
			// Refresh cache.
			// Uncommitted terms are cached by default.
			//
			if( $doReload						// Reload,
			 || ($this->mPredicate === NULL) )	// or not cached.
			{
				//
				// Handle term object.
				//
				$term = $this->offsetGet( kTAG_PREDICATE );
				if( $term instanceof COntologyTerm )
					return $term;													// ==>
				
				//
				// Load term object.
				//
				$this->mPredicate
					= $this->NewObject
						( COntologyTerm::ResolveClassContainer( $theConnection, TRUE ),
						  $term );
			
			} // Reload or empty cache.
			
			//
			// Handle not found.
			//
			if( $this->mPredicate === NULL )
				throw new Exception
					( "Predicate term not found",
					  kERROR_STATE );											// !@! ==>
		
		} // Has term.
		
		return $this->mPredicate;													// ==>

	} // LoadPredicate.

	 
	/*===================================================================================
	 *	LoadObject																		*
	 *==================================================================================*/

	/**
	 * <h4>Load object node object</h4>
	 *
	 * This method will return the current object node object: if the node is not set, the
	 * method will return <tt>NULL</tt>; if the node cannot be found, the method will raise
	 * an exception.
	 *
	 * The object will also be loaded in a data member that can function as a cache.
	 *
	 * The method features two parameters: the first refers to the container in which the
	 * node is stored, the second is a boolean flag that determines whether the object
	 * is to be read, or if the cached copy can be used.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param boolean				$doReload			Reload if <tt>TRUE</tt>.
	 *
	 * @access public
	 * @return COntologyNode		Node object or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 *
	 * @uses NewObject()
	 *
	 * @see kTAG_OBJECT
	 */
	public function LoadObject( CConnection $theConnection, $doReload = FALSE )
	{
		//
		// Check offset.
		//
		if( $this->offsetExists( kTAG_OBJECT ) )
		{
			//
			// Refresh cache.
			// Uncommitted nodes are cached by default.
			//
			if( $doReload						// Reload,
			 || ($this->mObject === NULL) )	// or not cached.
			{
				//
				// Handle node object.
				//
				$node = $this->offsetGet( kTAG_OBJECT );
				if( $node instanceof COntologyNode )
					return $node;													// ==>
				
				//
				// Load node object.
				//
				$this->mObject
					= $this->NewObject
						( COntologyNode::ResolveClassContainer( $theConnection, TRUE ),
						  $node );
			
			} // Reload or empty cache.
			
			//
			// Handle not found.
			//
			if( $this->mObject === NULL )
				throw new Exception
					( "Object vertex node not found",
					  kERROR_STATE );											// !@! ==>
		
		} // Has term.
		
		return $this->mObject;														// ==>

	} // LoadObject.

		

/*=======================================================================================
 *																						*
 *								STATIC CONTAINER INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	DefaultContainerName															*
	 *==================================================================================*/

	/**
	 * <h4>Return the default edges container name</h4>
	 *
	 * This class uses the {@link kCONTAINER_EDGE_NAME} default name.
	 *
	 * @static
	 * @return string				The default container name.
	 *
	 * @throws Exception
	 *
	 * @see kCONTAINER_EDGE_NAME
	 */
	static function DefaultContainerName()				{	return kCONTAINER_EDGE_NAME;	}

		

/*=======================================================================================
 *																						*
 *								STATIC RESOLUTION INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	Resolve																			*
	 *==================================================================================*/

	/**
	 * <h4>Resolve an edge</h4>
	 *
	 * This method can be used to retrieve an existing edge by identifier.
	 *
	 * The method accepts the following parameters:
	 *
	 * <ul>
	 *	<li><tt>$theConnection</tt>: This parameter represents the connection from which the
	 *		nodes container must be resolved. If this parameter cannot be correctly
	 *		determined, the method will raise an exception.
	 *	<li><tt>$theIdentifier</tt>: This parameter represents the edge unique, global,
	 *		native identifier or object, depending on its type:
	 *	 <ul>
	 *		<li><tt>integer</tt>: In this case the method assumes that the parameter
	 *			represents the edge identifier: it will attempt to retrieve the edge, if it
	 *			is not found, the method will return <tt>NULL</tt>.
	 *		<li><tt>{@link COntologyEdge}</tt>: In this case the method will use the
	 *			provided edge's unique identifier.
	 *		<li><i>other</i>: Any other type will be interpreted either as the edge's unique
	 *			identifier, or as the edges's global identifier: the method will return the
	 *			matching edge or <tt>NULL</tt>.
	 *	 </ul>
	 *	<li><tt>$doThrow</tt>: If <tt>TRUE</tt>, any failure to resolve the edge will raise
	 *		an exception.
	 * </ul>
	 *
	 * The method will return the found edge, <tt>NULL</tt> if not found, or raise an
	 * exception if the last parameter is <tt>TRUE</tt>.
	 *
	 * <b>Note: do not provide an array containing the object in the identifier parameter,
	 * or you will get unexpected results.</b>
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param mixed					$theIdentifier		Edge reference.
	 * @param boolean				$doThrow			If <tt>TRUE</tt> raise an exception.
	 *
	 * @static
	 * @return COntologyEdge		Found edge or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 */
	static function Resolve( CConnection $theConnection, $theIdentifier, $doThrow = FALSE )
	{
		//
		// Check identifier.
		//
		if( $theIdentifier !== NULL )
		{
			//
			// Resolve container.
			//
			$container = COntologyEdge::ResolveClassContainer( $theConnection, TRUE );
			
			//
			// Handle edge native identifier.
			//
			if( is_integer( $theIdentifier ) )
			{
				//
				// Get edge.
				//
				$edge = static::NewObject( $theConnection, $theIdentifier );
				if( (! $doThrow)
				 || ($edge !== NULL) )
					return $edge;													// ==>
				
				throw new Exception
					( "Edge not found",
					  kERROR_NOT_FOUND );										// !@! ==>
			
			} // Provided edge identifier.
			
			//
			// Init local storage.
			//
			$query = $container->NewQuery();
			
			//
			// Handle edge object.
			//
			if( $theIdentifier instanceof COntologyEdge )
			{
				//
				// Build global identifier.
				//
				$ident = $theIdentifier->GID();
				if( $ident === NULL )
				{
					//
					// Resolve subject.
					//
					$subject = $theIdentifier->LoadSubject( $theConnection );
					if( $subject !== NULL )
					{
						//
						// Resolve predicate.
						//
						$predicate = $theIdentifier->LoadPredicate( $theConnection );
						if( $predicate !== NULL )
						{
							//
							// Resolve object.
							//
							$object = $theIdentifier->LoadObject( $theConnection );
							if( $object !== NULL )
								$ident = implode( kTOKEN_INDEX_SEPARATOR,
												  array( $subject[ kTAG_NID ],
														 $predicate[ kTAG_GID ],
														 $object[ kTAG_NID ] ) );
						
						} // Resolved predicate.
					
					} // Resolved subject.
				
				} // Not yet committed.
				
				//
				// Check edge global identifier.
				//
				if( $ident === NULL )
				{
					if( $doThrow )
						throw new Exception
							( "Unable to resolve edge elements",
							  kERROR_PARAMETER );								// !@! ==>
				
					return NULL;													// ==>
					
				} // Unable to resolve elements.
				
				//
				// Convert to unique identifier.
				// By convention it is the binary md5 of the GID.
				//
				$query->AppendStatement(
					CQueryStatement::Equals(
						kTAG_UID, md5( $ident, TRUE ), kTYPE_BINARY_STRING ) );
			
			} // Provided object.
			
			//
			// Assume unique identifier.
			//
			else
				$query->AppendStatement(
					CQueryStatement::Equals(
						kTAG_UID, $theIdentifier, kTYPE_BINARY_STRING ) );
			
			//
			// Query.
			//
			$rs = $container->Query( $query, NULL, NULL, NULL, NULL, TRUE );
			if( ($rs === NULL)
			 && (! ($theIdentifier instanceof COntologyEdge)) )
			{
				//
				// Assume global identifier.
				//
				$query = $container->NewQuery();
				$query->AppendStatement(
					CQueryStatement::Equals(
						kTAG_UID, md5( $theIdentifier, TRUE ), kTYPE_BINARY_STRING ) );
				$rs = $container->Query( $query, NULL, NULL, NULL, NULL, TRUE );
			
			} // Not unique identifier.
			
			//
			// Found edge.
			//
			if( $rs !== NULL )
				return CPersistentObject::DocumentObject( $rs  );					// ==>

			//
			// Raise exception.
			//
			if( $doThrow )
				throw new Exception
					( "Edge not found",
					  kERROR_NOT_FOUND );										// !@! ==>
			
			return NULL;															// ==>
			
		} // Provided local or global identifier.
		
		throw new Exception
			( "Missing edge reference",
			  kERROR_PARAMETER );												// !@! ==>

	} // Resolve.

		

/*=======================================================================================
 *																						*
 *							PROTECTED IDENTIFICATION INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_index																			*
	 *==================================================================================*/

	/**
	 * <h4>Return the object's global unique identifier</h4>
	 *
	 * We override the parent method to handle the referenced objects: in this class the
	 * global identifier is the concatenation of the subject node native identifier, the
	 * predicate global identifier and the object node native identifier all separated by
	 * the {@link kTOKEN_INDEX_SEPARATOR} token.
	 *
	 * This method will also automatically fill the persistent path, {@link kTAG_PATH},
	 * and identifier, {@link kTAG_PID}, in which the vertex node identifiers are replaced
	 * by their related term global identifiers. These attributes are useful for debugging
	 * purposes and to provide a persistent identifier to the edge.
	 *
	 * @param CConnection			$theConnection		Server, database or container.
	 * @param bitfield				$theModifiers		Commit options.
	 *
	 * @throws Exception
	 *
	 * @access protected
	 * @return string|NULL			The object's global unique identifier.
	 *
	 * @throws Exception
	 *
	 * @uses LoadSubject()
	 * @uses LoadPredicate()
	 * @uses LoadObject()
	 *
	 * @see kTAG_NID kTAG_GID kTAG_PID kTAG_PATH kTOKEN_INDEX_SEPARATOR
	 */
	protected function _index( CConnection $theConnection, $theModifiers )
	{
		//
		// Init global identifier.
		//
		$identifier = $persistent = $debug = Array();
		
		//
		// Get subject.
		//
		if( ($tmp = $this->LoadSubject( $theConnection )) !== NULL )
		{
			//
			// Load debug.
			//
			$debug[] = ( $tmp->offsetExists( kTAG_GID ) )
					 ? $tmp->offsetGet( kTAG_GID )
					 : OntologyTerm::Resolve(
						   $theConnection, $tmp->Term(), NULL, TRUE )
							   ->GID();

			//
			// Load persistent.
			//
			$persistent[] = $tmp[ kTAG_TERM ];

			//
			// Load identifier.
			//
			$identifier[] = (string) $tmp[ kTAG_NID ];
		
		} // Has subject.
		
		else
			throw new Exception
				( "Missing subject vertex",
				  kERROR_STATE );												// !@! ==>
		
		//
		// Get predicate.
		//
		if( ($tmp = $this->LoadPredicate( $theConnection )) !== NULL )
		{
			//
			// Load debug.
			//
			$debug[] = $tmp[ kTAG_GID ];

			//
			// Load persistent.
			//
			$persistent[] = $tmp[ kTAG_NID ];
		
			//
			// Load identifier.
			//
			$identifier[] = $tmp[ kTAG_GID ];
		
		} // Has predicate.
		
		else
			throw new Exception
				( "Missing predicate",
				  kERROR_STATE );												// !@! ==>
		
		//
		// Get object.
		//
		if( ($tmp = $this->LoadObject( $theConnection )) !== NULL )
		{
			//
			// Load debug.
			//
			$debug[] = ( $tmp->offsetExists( kTAG_GID ) )
					 ? $tmp->offsetGet( kTAG_GID )
					 : OntologyTerm::Resolve(
						   $theConnection, $tmp->Term(), NULL, TRUE )
							   ->GID();

			//
			// Load persistent.
			//
			$persistent[] = $tmp[ kTAG_TERM ];

			//
			// Load identifier.
			//
			$identifier[] = (string) $tmp[ kTAG_NID ];
		
		} // Has subject.
		
		else
			throw new Exception
				( "Missing object vertex",
				  kERROR_STATE );												// !@! ==>
		
		//
		// Set object persistent identifiers.
		//
		$this->offsetSet( kTAG_PATH, $persistent );
		$this->offsetSet( kTAG_PID, implode( kTOKEN_INDEX_SEPARATOR, $debug ) );
		
		return implode( kTOKEN_INDEX_SEPARATOR, $identifier );						// ==>
	
	} // _index.

		

/*=======================================================================================
 *																						*
 *								PROTECTED OFFSET INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_Preset																			*
	 *==================================================================================*/

	/**
	 * <h4>Handle offset before setting it</h4>
	 *
	 * In this class we handle the subject, predicate and object offsets, if provided as
	 * objects we leave them unchanged only if not yet committed, if not, we convert them to
	 * their native identifiers.
	 *
	 * We also ensure that the provided objects are instances of the correct classes by
	 * asserting {@link CDocument} descendants.
	 *
	 * @param reference			   &$theOffset			Offset.
	 * @param reference			   &$theValue			Value to set at offset.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @uses _IsCommitted()
	 * @uses _AssertClass()
	 *
	 * @see kTAG_PREDICATE kTAG_OBJECT kTAG_SUBJECT
	 */
	protected function _Preset( &$theOffset, &$theValue )
	{
		//
		// Parse by offset.
		//
		switch( $theOffset )
		{
			case kTAG_PREDICATE:
	
				//
				// Lock term if object is committed.
				//
				if( $this->_IsCommitted() )
					throw new Exception
						( "You cannot modify the [$theOffset] offset: "
						 ."the object is committed",
						  kERROR_LOCKED );										// !@! ==>
				
				//
				// Check value type.
				//
				$ok = $this->_AssertClass( $theValue, 'CDocument', 'COntologyTerm' );
				
				//
				// Handle wrong object.
				//
				if( $ok === FALSE )
					throw new Exception
						( "Cannot set predicate: "
						 ."the object must be a term reference or object",
						  kERROR_PARAMETER );									// !@! ==>
				
				//
				// Handle right object.
				//
				if( $ok )
				{
					//
					// Use native identifier.
					//
					if( $theValue->_IsCommitted() )
					{
						//
						// Check native identifier.
						//
						if( $theValue->offsetExists( kTAG_NID ) )
							$theValue = $theValue->offsetGet( kTAG_NID );
						else
							throw new Exception
								( "Cannot set predicate: "
								 ."the object is missing its native identifier",
								  kERROR_PARAMETER );							// !@! ==>
					
					} // Object is committed.
					
					//
					// Copy to data member.
					//
					else
						$this->mPredicate = $theValue;
				
				} // Correct object class.
				
				break;

			case kTAG_OBJECT:
			case kTAG_SUBJECT:
			
				//
				// Lock node if object is committed.
				//
				if( $this->_IsCommitted() )
					throw new Exception
						( "You cannot modify the [$theOffset] offset: "
						 ."the object is committed",
						  kERROR_LOCKED );										// !@! ==>
				
				//
				// Check value type.
				//
				$ok = $this->_AssertClass( $theValue, 'CDocument', 'COntologyNode' );
				
				//
				// Handle wrong object.
				//
				if( $ok === FALSE )
				{
					if( $theOffset == kTAG_OBJECT )
						throw new Exception
							( "Cannot set object vertex: "
							 ."the object must be a node reference or object",
							  kERROR_PARAMETER );								// !@! ==>
					else
						throw new Exception
							( "Cannot set subject vertex: "
							 ."the object must be a node reference or object",
							  kERROR_PARAMETER );								// !@! ==>
				}
				
				//
				// Handle right object.
				//
				if( $ok )
				{
					//
					// Use native identifier.
					//
					if( $theValue->_IsCommitted() )
					{
						//
						// Check native identifier.
						//
						if( $theValue->offsetExists( kTAG_NID ) )
							$theValue = $theValue->offsetGet( kTAG_NID );
						else
						{
							if( $theOffset == kTAG_OBJECT )
								throw new Exception
									( "Cannot set object vertex: "
									 ."the object is missing its native identifier",
									  kERROR_PARAMETER );						// !@! ==>
							else
								throw new Exception
									( "Cannot set subject vertex: "
									 ."the object is missing its native identifier",
									  kERROR_PARAMETER );						// !@! ==>
						}
					
					} // Object is committed.
					
					//
					// Copy to data member.
					//
					else
					{
						if( $theOffset == kTAG_OBJECT )
							$this->mObject = $theValue;
						else
							$this->mSubject = $theValue;
					}
				
				} // Correct object class.
				
				break;
		
		} // Parsed by offset.
		
		//
		// Call parent method.
		//
		parent::_Preset( $theOffset, $theValue );
	
	} // _Preset.

	 
	/*===================================================================================
	 *	_Preunset																		*
	 *==================================================================================*/

	/**
	 * <h4>Handle offset before unsetting it</h4>
	 *
	 * In this class we prevent the modification of the subject, predicate and object
	 * offsets if the object is committed.
	 *
	 * @param reference			   &$theOffset			Offset.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @uses _IsCommitted()
	 *
	 * @see kTAG_PREDICATE kTAG_OBJECT kTAG_SUBJECT
	 */
	protected function _Preunset( &$theOffset )
	{
		//
		// Lock subject, predicate and object vertices if object is committed.
		//
		$offsets = array( kTAG_SUBJECT,
						  kTAG_PREDICATE,
						  kTAG_OBJECT );
		if( in_array( $theOffset, $offsets )
		 && $this->_IsCommitted() )
			throw new Exception
				( "You cannot modify the [$theOffset] offset: "
				 ."the object is committed",
				  kERROR_LOCKED );												// !@! ==>
		
		//
		// Call parent method.
		//
		parent::_Preunset( $theOffset );
	
	} // _Preunset.
		


/*=======================================================================================
 *																						*
 *							PROTECTED PRE-COMMIT INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_PrecommitRelated																*
	 *==================================================================================*/

	/**
	 * <h4>Handle embedded or related objects before committing</h4>
	 *
	 * In this class we commit the eventual term provided as an uncommitted object and
	 * replace the offset with the term's native identifier, or load the term if provided
	 * as an identifier.
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 * @return mixed
	 *
	 * @uses LoadSubject()
	 * @uses LoadPredicate()
	 * @uses LoadObject()
	 *
	 * @see kTAG_PREDICATE kTAG_OBJECT kTAG_SUBJECT
	 */
	protected function _PrecommitRelated( &$theConnection, &$theModifiers )
	{
		//
		// Call parent method.
		//
		$status = parent::_PrecommitRelated( $theConnection, $theModifiers );
		if( $status !== NULL )
			return $status;															// ==>
		
		//
		// Not deleting.
		//
		if( ! ($theModifiers & kFLAG_PERSIST_DELETE) )
		{
			//
			// Handle subject vertice object.
			// Note that we let _Preset() method take care of the specific class.
			// Note that we do not check the object: it is required to be inited.
			//
			$object = $this->offsetGet( kTAG_SUBJECT );
			if( $object instanceof COntologyNode )
			{
				//
				// Commit.
				// Note that we insert, to ensure the object is new.
				//
				$object->Insert(
					COntologyNode::ResolveClassContainer(
						$theConnection, TRUE ) );
				
				//
				// Cache it.
				//
				$this->mSubject = $object;
				
				//
				// Set identifier in subject offset.
				//
				$this->offsetSet( kTAG_SUBJECT,
								  $this->mSubject->offsetGet( kTAG_NID ) );
				
			} // Subject is object.
			
			//
			// Handle subject identifier.
			//
			else
				$this->LoadSubject( $theConnection, TRUE );
		
			//
			// Handle predicate object.
			// Note that we let _Preset() method take care of the specific class.
			// Note that we do not check the object: it is required to be inited.
			//
			$object = $this->offsetGet( kTAG_PREDICATE );
			if( $object instanceof COntologyTerm )
			{
				//
				// Commit.
				// Note that we insert, to ensure the object is new.
				//
				$object->Insert(
					COntologyTerm::ResolveClassContainer(
						$theConnection, TRUE ) );
				
				//
				// Cache it.
				//
				$this->mPredicate = $object;
				
				//
				// Set identifier in predicate offset.
				//
				$this->offsetSet( kTAG_PREDICATE,
								  $this->mPredicate->offsetGet( kTAG_NID ) );
				
			} // Predicate is object.
			
			//
			// Handle predicate identifier.
			//
			else
				$this->LoadPredicate( $theConnection, TRUE );
		
			//
			// Handle object vertice object.
			// Note that we let _Preset() method take care of the specific class.
			// Note that we do not check the object: it is required to be inited.
			//
			$object = $this->offsetGet( kTAG_OBJECT );
			if( $object instanceof COntologyNode )
			{
				//
				// Commit.
				// Note that we insert, to ensure the object is new.
				//
				$object->Insert(
					COntologyNode::ResolveClassContainer(
						$theConnection, TRUE ) );
				
				//
				// Cache it.
				//
				$this->mObject = $object;
				
				//
				// Set identifier in object offset.
				//
				$this->offsetSet( kTAG_OBJECT,
								  $this->mObject->offsetGet( kTAG_NID ) );
				
			} // Object is object.
			
			//
			// Handle object identifier.
			//
			else
				$this->LoadObject( $theConnection, TRUE );
		
		} // Not deleting.
		
		return NULL;																// ==>
	
	} // _PrecommitRelated.

	 
	/*===================================================================================
	 *	_PrecommitIdentify																*
	 *==================================================================================*/

	/**
	 * <h4>Determine the identifiers before committing</h4>
	 *
	 * This method will use the result of the {@link _index()} method to set the global
	 * identifier, {@link kTAG_GID}; the same value will be hashed and constitute the
	 * unique identifier, {@link kTAG_UID}.
	 *
	 * This method will also take care of generating the sequence number that represents the
	 * object's native identifier, {@link kTAG_NID}, this value can be generated in two
	 * ways:
	 *
	 * <ul>
	 *	<li><i>The container has the graph reference, {@link kOFFSET_GRAPH}</i>: If the
	 *		provided container contains a reference to a graph container, it means that the
	 *		edge must also be stored in the graph, this will be taken care by the
	 *		{@link _AddGraphEdge()} method that will return the graph edge's ID, which in
	 *		turn will become the current object's {@link kTAG_NID}.
	 *	<li><i>The container lacks the graph reference, {@link kOFFSET_GRAPH}</i>: If the
	 *		provided container does not hold a reference to a graph container, the object
	 *		identifier will be generated with a sequence number tagged
	 *		{@link kSEQUENCE_KEY_EDGE}, this method will set the native identifier,
	 *		{@link kTAG_NID}, with this value.
	 * </ul>
	 *
	 * When deleting the object, if the provided container contains a reference to a graph
	 * container, this method will also delete the relative edge from the graph.
	 *
	 * The parent method will then be called, which will ignore the global and native
	 * identifiers, since they will have been set here.
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 * @return mixed
	 *
	 * @throws Exception
	 *
	 * @see kSEQUENCE_KEY_EDGE
	 * @see kTAG_NID kTAG_GID kTAG_UID
	 * @see kFLAG_PERSIST_INSERT kFLAG_PERSIST_REPLACE
	 */
	protected function _PrecommitIdentify( &$theConnection, &$theModifiers )
	{
		//
		// Handle insert or replace.
		//
		if( (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_INSERT)
		 || (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_REPLACE) )
		{
			//
			// Set global identifier.
			//
			if( ! $this->offsetExists( kTAG_GID ) )
			{
				//
				// Generate global identifier.
				//
				$index = $this->_index( $theConnection, $theModifiers );
				if( $index !== NULL )
				{
					//
					// Set global identifier.
					//
					$this->offsetSet( kTAG_GID, $index );
					
					//
					// Resolve container.
					//
					$container = self::ResolveContainer( $theConnection, TRUE );
					
					//
					// Generate unique identifier.
					//
					$uid = md5( $index, TRUE );
					$container->UnserialiseData( $uid, kTYPE_BINARY_STRING );
					
					//
					// Check unique identifier.
					//
					if( $container->CheckObject( $uid, kTAG_UID ) )
						throw new Exception
							( "Duplicate object",
							  kERROR_COMMIT );									// !@! ==>
					
					//
					// Set unique identifier.
					//
					$this->offsetSet( kTAG_UID, $uid );
				
				} // Has global identifier.
			
			} // Missing global identifier.
		
			//
			// Set native identifier.
			//
			if( ! $this->offsetExists( kTAG_NID ) )
			{
				//
				// Resolve container.
				//
				$container = static::ResolveContainer( $theConnection, TRUE );
				
				//
				// Handle graph.
				//
				if( $container->offsetExists( kOFFSET_GRAPH ) )
					$id = $this->_AddGraphEdge( $container->offsetGet( kOFFSET_GRAPH ) );
				
				//
				// Handle sequence number.
				//
				else
					$id = $container->NextSequence( kSEQUENCE_KEY_EDGE, TRUE );
				
				//
				// Set identifier.
				//
				$this->offsetSet( kTAG_NID, $id );
			
			} // Missing native identifier.
		
		} // Insert or replace.
		
		//
		// Handle delete.
		//
		elseif( $theModifiers & kFLAG_PERSIST_DELETE )
		{
			//
			// Resolve container.
			//
			$container = static::ResolveContainer( $theConnection, TRUE );
			
			//
			// Handle graph.
			//
			if( $container->offsetExists( kOFFSET_GRAPH ) )
				$container->offsetGet( kOFFSET_GRAPH )
					->DelEdge( $this->offsetGet( kTAG_NID ) );
		
		} // Delete.
	
		//
		// Call parent method.
		//
		return parent::_PrecommitIdentify( $theConnection, $theModifiers );			// ==>
		
	} // _PrecommitIdentify.
		


/*=======================================================================================
 *																						*
 *							PROTECTED POST-COMMIT INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_PostcommitRelated																*
	 *==================================================================================*/

	/**
	 * <h4>Update related objects after committing</h4>
	 *
	 * In this class we handle the {@link kTAG_EDGES} attribute of the nodes referenced by
	 * this object depending on the value of the {@link kSWITCH_kTAG_EDGES} flag we do the
	 * following:
	 *
	 * <ul>
	 *	<li><tt>0x2</tt>: <i>Keep count of references</i>. This means that the
	 *		{@link kTAG_EDGES} attribute of the subject or object nodes referenced by the
	 *		current object will be incremented when the object is inserted, or decremented
	 *		when deleted.
	 *	<li><tt>0x3</tt>: <i>Keep list of references</i>. This means that a reference to the
	 *		current object will be added to the {@link kTAG_EDGES} attribute of the
	 *		referenced subject or object nodes and removed when the object is deleted.
	 *	<li><tt>0x0</tt> <i>or other</i>: <i>Don't handle this information</i>. This means
	 *		that the {@link kTAG_EDGES} attribute will not be handled.
	 * </ul>
	 *
	 * Note that you should provide either a database connection or the <i>node</i>
	 * container to this method in order to make it work!
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 *
	 * @uses _IsCommitted()
	 * @uses _ReferenceInObject()
	 *
	 * @see kTAG_EDGES kTAG_SUBJECT kTAG_OBJECT
	 * @see kFLAG_PERSIST_INSERT kFLAG_PERSIST_REPLACE kFLAG_PERSIST_DELETE
	 * @see kFLAG_PERSIST_MODIFY kFLAG_MODIFY_ADDSET kFLAG_MODIFY_PULL
	 */
	protected function _PostcommitRelated( &$theConnection, &$theModifiers )
	{
		//
		// Call parent method.
		//
		parent::_PostcommitRelated( $theConnection, $theModifiers );
	
		//
		// Handle insert or replace.
		//
		if( (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_INSERT)
		 || (($theModifiers & kFLAG_PERSIST_MASK) == kFLAG_PERSIST_REPLACE) )
		{
			//
			// Check if not yet committed.
			//
			if( ! $this->_IsCommitted() )
			{
				//
				// Add current edge reference to subject vertex referenced.
				//
				$this->_ReferenceInObject(
					COntologyNode::ResolveContainer( $theConnection, TRUE ),
					kSWITCH_kTAG_EDGES,
					$this->offsetGet( kTAG_SUBJECT ),
					kTAG_EDGES,
					1 );
				
				//
				// Add current edge reference to subject vertex referenced.
				//
				$this->_ReferenceInObject(
					COntologyNode::ResolveContainer( $theConnection, TRUE ),
					kSWITCH_kTAG_EDGES,
					$this->offsetGet( kTAG_OBJECT ),
					kTAG_EDGES,
					1 );
				
				//
				// Handle alias subject.
				//
				if( ($id = $this->mSubject->offsetGet( kTAG_NODE )) !== NULL )
				{
					//
					// Resolve master.
					//
					$master = COntologyMasterNode::NewObject( $theConnection, $id, TRUE );
					
					//
					// Resolve object.
					//
					$object = ( ($id = $this->mObject->offsetGet( kTAG_NODE )) !== NULL )
							? $id
							: $this->mObject;
					
					//
					// Mirror relationship.
					//
					$master->RelateTo( $this->mPredicate, $object, $theConnection );
				
				} // Subject is alias.
				
			} // Not yet committed.
		
		} // Insert or replace.
		
		//
		// Check if deleting.
		//
		elseif( $theModifiers & kFLAG_PERSIST_DELETE )
		{
			//
			// Remove current edge reference from subject vertex referenced.
			//
			$this->_ReferenceInObject(
				COntologyNode::ResolveContainer( $theConnection, TRUE ),
				kSWITCH_kTAG_EDGES,
				$this->offsetGet( kTAG_SUBJECT ),
				kTAG_EDGES,
				-1 );
			
			//
			// Remove current edge reference from subject vertex referenced.
			//
			$this->_ReferenceInObject(
				COntologyNode::ResolveContainer( $theConnection, TRUE ),
				kSWITCH_kTAG_EDGES,
				$this->offsetGet( kTAG_OBJECT ),
				kTAG_EDGES,
				-1 );
		
		} // Deleting.
		
	} // _PostcommitRelated.

	 
	/*===================================================================================
	 *	_PostcommitCleanup																*
	 *==================================================================================*/

	/**
	 * <h4>Cleanup the object after committing</h4>
	 *
	 * In this class we reset the term object cache, we set the data members to
	 * <tt>NULL</tt> so that next time one wants to retrieve related objects, the cache will
	 * have to be refreshed.
	 *
	 * @param reference			   &$theConnection		Server, database or container.
	 * @param reference			   &$theModifiers		Commit options.
	 *
	 * @access protected
	 */
	protected function _PostcommitCleanup( &$theConnection, &$theModifiers )
	{
		//
		// Call parent method.
		//
		parent::_PostcommitCleanup( $theConnection, $theModifiers );
		
		//
		// Reset objects cache.
		//
		$this->mSubject = $this->mPredicate = $this->mObject = NULL;
	
	} // _PostcommitCleanup.

		

/*=======================================================================================
 *																						*
 *								PROTECTED GRAPH INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	_AddGraphEdge																	*
	 *==================================================================================*/

	/**
	 * <h4>Create graph edge</h4>
	 *
	 * This method will create and save a new graph edge in the provided graph container and
	 * return its newly created identifier.
	 *
	 * This method is called by {@link _PrecommitIdentify()} to set the new edge
	 * {@link kTAG_NID} and the method makes no assumption whether the edge exists
	 * already or not, in all cases it will create a new edge.
	 *
	 * This method will set the node identifiers in the {@link kTAG_SUBJECT} and
	 * {@link kTAG_OBJECT} properties and the predicate term {@link kTAG_GID} as the
	 * predicate identifier.
	 * 
	 following attributes to the graph edge: {@link kTAG_KIND}
	 * and {@link kTAG_TYPE}, derived classes may override this method to add other
	 * properties.
	 *
	 * The method should raise an exception if the node was not created.
	 *
	 * @param CGraphContainer		$theGraph			Graph container.
	 *
	 * @access protected
	 * @return integer				Newly created edge ID.
	 */
	protected function _AddGraphEdge( CGraphContainer $theGraph )
	{
		//
		// Create edge.
		//
		$edge = $theGraph->NewEdge( $this->Subject(),
									$this->mPredicate->GID(),
									$this->Object() );
		
		//
		// Save edge.
		//
		$id = $theGraph->SetEdge( $edge );
		
		//
		// Return identifier.
		//
		if( is_integer( $id ) )
			return $id;																// ==>
		
		throw new Exception
			( "Unable to create graph edge",
			  kERROR_STATE );													// !@! ==>
	
	} // _AddGraphEdge.

	 

} // class COntologyEdge.


?>
